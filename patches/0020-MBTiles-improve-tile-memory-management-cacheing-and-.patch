From 022dcf710144473de51aa689948befa29138ddf4 Mon Sep 17 00:00:00 2001
From: Dave <bdbcat@yahoo.com>
Date: Sat, 31 Aug 2024 22:59:17 -0400
Subject: [PATCH] MBTiles, improve tile memory management, cacheing and
 rendering logic. #4124

---
 gui/src/mbtiles/TileCache.hpp      | 115 +++++------------------------
 gui/src/mbtiles/TileDescriptor.hpp |  12 ++-
 gui/src/mbtiles/WorkerThread.cpp   |   4 +-
 gui/src/mbtiles/mbtiles.cpp        |   2 +-
 4 files changed, 33 insertions(+), 100 deletions(-)

diff --git a/gui/src/mbtiles/TileCache.hpp b/gui/src/mbtiles/TileCache.hpp
index c63cb47b8..7068ccc0b 100644
--- a/gui/src/mbtiles/TileCache.hpp
+++ b/gui/src/mbtiles/TileCache.hpp
@@ -19,9 +19,6 @@ class TileCache {
   ZoomDescriptor *zoomTable;
   int minZoom, maxZoom, nbZoom;
   // Chained list parameters
-  mbTileDescriptor *listStart = nullptr;
-  mbTileDescriptor *listEnd = nullptr;
-  uint32_t listSize = 0;
 
 public:
   TileCache(int minZoom, int maxZoom, float LonMin, float LatMin, float LonMax,
@@ -56,6 +53,12 @@ class TileCache {
     return mutexes[tile_id % kMutexCount];
   }
 
+  static std::mutex &GetMutex(const mbTileDescriptor *tile) {
+    uint64_t key = mbTileDescriptor::GetMapKey(tile->m_zoomLevel, tile->tile_x,
+                                               tile->tile_y);
+    return TileCache::GetMutex(key);
+  }
+
   /// @brief Flush the tile cache, including OpenGL texture memory if needed
   void Flush() {
     for (auto const &it : tileMap) {
@@ -67,10 +70,6 @@ class TileCache {
         delete tile;
       }
     }
-    // Reset the chained list
-    listStart = nullptr;
-    listEnd = nullptr;
-    listSize = 0;
   }
 
   // Get the north limit of the cache area for a given zoom in WMTS coordinates
@@ -85,7 +84,7 @@ class TileCache {
 
   /// @brief Get the current size of the cache in number of tiles
   /// @return Number of tiles in the cache
-  uint32_t GetCacheSize() { return listSize; }
+  uint32_t GetCacheSize() const { return tileMap.size(); }
 
   /// @brief Retreive a tile from the cache. If the tile is not present in the
   /// cache, an empty tile is created and added.
@@ -98,9 +97,7 @@ class TileCache {
     auto ref = tileMap.find(index);
     if (ref != tileMap.end()) {
       // The tile is in the cache
-      // Move it to the beginning of the tile list so that the list will have
-      // the most frequently needed tiles at the beginning
-      MoveTileToListStart(ref->second);
+      ref->second->SetTimestamp();
       return ref->second;
     }
 
@@ -108,8 +105,6 @@ class TileCache {
     // map and list
     mbTileDescriptor *tile = new mbTileDescriptor(z, x, y);
     tileMap[index] = tile;
-    AddTileToList(tile);
-
     return tile;
   }
 
@@ -119,93 +114,23 @@ class TileCache {
   /// only be called by rendering thread since it uses OpenGL calls.
   /// @param maxTiles Maximum number of tiles to be kept in the list
   void CleanCache(uint32_t maxTiles) {
-    uint64_t key;
-
-    while (listSize > maxTiles) {
-      // List size exceeds the maximum value : delete the last tile of the list
-      key = mbTileDescriptor::GetMapKey(listEnd->m_zoomLevel, listEnd->tile_x,
-                                        listEnd->tile_y);
-      std::lock_guard lock(TileCache::GetMutex(key));
-      auto ref = tileMap.find(key);
-      // Remove the tile from map and delete it. Tile destructor takes care to
-      // properly delete associated resources.
-      tileMap.erase(ref);
-      DeleteTileFromList(listEnd);
-    }
-  }
+    if (tileMap.size() <= maxTiles) return;
 
-private:
-  /// @brief Add a new tile to the tile list.
-  /// @param tile Pointer to the tile
-  void AddTileToList(mbTileDescriptor *tile) {
-    if (listStart == nullptr) {
-      // List is empty : add the first element
-      tile->prev = nullptr;
-      tile->next = nullptr;
-      listStart = tile;
-      listEnd = tile;
-    } else {
-      // Insert tile at the start of the list
-      tile->prev = nullptr;
-      tile->next = listStart;
-      listStart->prev = tile;
-      listStart = tile;
-    }
-    // Update list size
-    listSize++;
-  }
-
-  /// @brief Remove a tile from the tile list and delete it.
-  /// @param tile Pointer to the tile to be deleted
-  void DeleteTileFromList(mbTileDescriptor *tile) {
-    if (tile) {
-      if (tile->prev == nullptr) {
-        // Tile is at beginning of the list
-        listStart = tile->next;
-      } else {
-        tile->prev->next = tile->next;
-      }
+    /** Create a sorted list of keys, oldest first. */
+    std::vector<uint64_t> keys;
+    for (auto &kv : tileMap) keys.push_back(kv.first);
+    auto compare = [&](const uint64_t lhs, const uint64_t rhs) {
+      return tileMap[lhs]->last_used < tileMap[rhs]->last_used;
+    };
+    std::sort(keys.begin(), keys.end(), compare);
 
-      if (tile->next == nullptr) {
-        // Tile is at the end of the list
-        listEnd = tile->prev;
-      } else {
-        tile->next->prev = tile->prev;
-      }
+    for (size_t i = 0; i < tileMap.size() - maxTiles; i += 1) {
+      std::lock_guard lock(TileCache::GetMutex(tileMap[keys[i]]));
 
-      // Delete the tile
+      auto tile = tileMap[keys[i]];
+      tileMap.erase(keys[i]);
       delete tile;
-      listSize--;
-    }
-  }
-
-  /// @brief Move a tile at the beginning of the list.
-  /// @param tile Tile to be moved
-  void MoveTileToListStart(mbTileDescriptor *tile) {
-    if (tile) {
-      if (tile->prev == nullptr) {
-        // Tile is already at beginning of list : exit function
-        return;
-      }
-
-      if (tile->next == nullptr) {
-        // Tile is at the end of list : update list end pointer
-        listEnd = tile->prev;
-      } else {
-        // We have a successor : update its previous pointer
-        tile->next->prev = tile->prev;
-      }
-
-      // Tile's predecessor must have its next pointer updated
-      tile->prev->next = tile->next;
-
-      // Insert tile at beginning of list
-      listStart->prev = tile;
-      tile->next = listStart;
-      tile->prev = nullptr;
-      listStart = tile;
     }
   }
 };
-
 #endif
diff --git a/gui/src/mbtiles/TileDescriptor.hpp b/gui/src/mbtiles/TileDescriptor.hpp
index 997ed30e0..a9a949820 100644
--- a/gui/src/mbtiles/TileDescriptor.hpp
+++ b/gui/src/mbtiles/TileDescriptor.hpp
@@ -2,6 +2,7 @@
 #define _MBTILES_TILEDESCRIPTOR_H_
 
 #include <cstdint>
+#include <chrono>
 #include <atomic>
 #include <cmath>
 
@@ -15,6 +16,7 @@ class mbTileDescriptor {
   int m_zoomLevel;
   float latmin, lonmin, latmax, lonmax;
   LLBBox box;
+  std::chrono::milliseconds last_used;
 
   // Set to true if a load request from main thread is already pending for this
   // tile
@@ -50,6 +52,7 @@ class mbTileDescriptor {
     latmax = round(mbTileDescriptor::tiley2lat(tile_y, zoomFactor) / eps) * eps;
 
     box.Set(latmin, lonmin, latmax, lonmax);
+    SetTimestamp();
   }
 
   virtual ~mbTileDescriptor() {
@@ -111,8 +114,15 @@ class mbTileDescriptor {
     return 180.0 / M_PI * latRad;
   }
 
+  /** Update last_used to current time. */
+  void SetTimestamp() {
+    using namespace std::chrono;
+    last_used =
+        duration_cast<milliseconds>(system_clock::now().time_since_epoch());
+  }
+
 private:
   const double eps = 6e-6;  // about 1cm on earth's surface at equator
 };
 
-#endif /* _MBTILES_TILEDESCRIPTOR_H_ */
\ No newline at end of file
+#endif /* _MBTILES_TILEDESCRIPTOR_H_ */
diff --git a/gui/src/mbtiles/WorkerThread.cpp b/gui/src/mbtiles/WorkerThread.cpp
index 391ed391e..4727d78c7 100644
--- a/gui/src/mbtiles/WorkerThread.cpp
+++ b/gui/src/mbtiles/WorkerThread.cpp
@@ -78,9 +78,7 @@ wxThread::ExitCode MbtTilesThread::Entry() {
   /// @brief Load bitmap data of a tile from the MbTiles file to the tile cache
   /// @param tile Pointer to the tile to be loaded
 void MbtTilesThread::LoadTile(mbTileDescriptor *tile) {
-    uint64_t key = mbTileDescriptor::GetMapKey(tile->m_zoomLevel, tile->tile_x,
-                                               tile->tile_y);
-    std::lock_guard lock(TileCache::GetMutex(key));
+    std::lock_guard lock(TileCache::GetMutex(tile));
 
     // If the tile has not been found in the SQL database in a previous attempt,
     // don't search for it again
diff --git a/gui/src/mbtiles/mbtiles.cpp b/gui/src/mbtiles/mbtiles.cpp
index efc5e22ad..918ccb5c2 100644
--- a/gui/src/mbtiles/mbtiles.cpp
+++ b/gui/src/mbtiles/mbtiles.cpp
@@ -586,7 +586,7 @@ InitReturn ChartMBTiles::PostInit(void) {
 
   m_pDB = new SQLite::Database(name_UTF8);
   m_pDB->exec("PRAGMA locking_mode=EXCLUSIVE");
-  m_pDB->exec("PRAGMA cache_size=-50000");
+  m_pDB->exec("PRAGMA cache_size=-10000");
 
   bReadyToRender = true;
   return INIT_OK;
